// Generated by CoffeeScript 1.12.7
var PassThroughStream, TapParser, _, convert, escapeXml, fs, getFullname, processTest, readline;

_ = require('lodash');

fs = require('fs');

PassThroughStream = require('stream').PassThrough;

readline = require('readline');

TapParser = require('tap-parser');

escapeXml = function(str) {
  return String(str).replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/&/g, '&amp;');
};

getFullname = function(test) {
  var fullname, parent;
  fullname = test.name;
  parent = test;
  while (parent = parent.parent) {
    if (parent.name) {
      fullname = parent.name + ' ￫ ' + fullname;
    }
  }
  return fullname;
};

processTest = function(opts, test) {
  var fullname;
  fullname = getFullname(test);
  if (opts.editTestName) {
    fullname = opts.editTestName(fullname);
  }
  test.fullnameEscaped = escapeXml(fullname);
  return test;
};

convert = function(in_path, out_path, opts) {
  if (opts == null) {
    opts = {};
  }
  return new Promise(function(resolve, reject) {
    var attachListeners, parserStack, passthrough, read_stream, rl, rootParser, writeFooter, writeHeader, writeSkip, writeTest, writeTodo, write_stream;
    _.defaults(opts, {
      suiteName: 'TAP',
      editTestName: null,
      filterErrorStack: null
    });
    if (_.isString(in_path)) {
      read_stream = fs.createReadStream(in_path);
    } else {
      read_stream = in_path;
    }
    if (_.isString(out_path)) {
      write_stream = fs.createWriteStream(out_path);
    } else {
      write_stream = out_path;
    }
    writeHeader = function() {
      return write_stream.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuite name=\"" + (escapeXml(opts.suiteName)) + "\">\n");
    };
    writeFooter = function() {
      return write_stream.write('</testsuite>\n', function() {
        return resolve();
      });
    };
    writeSkip = function(parent, skip) {
      return write_stream.write("<testcase name=\"" + parent.fullnameEscaped + " ￫ " + skip.name + "\">\n	<skipped message=\"skip\"/>\n</testcase>\n");
    };
    writeTodo = function(parent, todo) {
      return write_stream.write("<testcase name=\"" + parent.fullnameEscaped + " ￫ " + todo.name + "\">\n	<skipped message=\"todo\"/>\n</testcase>\n");
    };
    writeTest = function(test) {
      var ref, ref1, ref2, ref3;
      processTest(opts, test);
      if ((ref = test.skips) != null) {
        ref.forEach(function(t) {
          if (t.skip) {
            writeSkip(test, t);
          }
          if (t.todo) {
            return writeTodo(test, t);
          }
        });
      }
      if (test.results.fail) {
        return write_stream.write("<testcase name=\"" + test.fullnameEscaped + "\">\n	<failure message=\"" + (((ref1 = test.results) != null ? (ref2 = ref1.failures) != null ? (ref3 = ref2[0]) != null ? ref3.name : void 0 : void 0 : void 0) || test.fullnameEscaped) + "\"><![CDATA[\n" + (escapeXml(test.lines.join('').trim())) + "\n	]]></failure>\n</testcase>\n");
      } else {
        return write_stream.write("<testcase name=\"" + test.fullnameEscaped + "\"></testcase>\n");
      }
    };
    rootParser = new TapParser({
      buffered: true,
      preserveWhitespace: false
    });
    parserStack = [];
    attachListeners = function(parser) {
      parserStack.push(parser);
      parser.on('child', function(child) {
        child.on('line', function(line) {
          if (child.lines == null) {
            child.lines = [];
          }
          return child.lines.push(line);
        });
        child.on('complete', function(result) {
          child.result = result;
          writeTest(child);
          return parserStack.pop();
        });
        return attachListeners(child);
      });
      parser.on('extra', function(extra) {
        return parserStack.forEach(function(p) {
          if (p.lines == null) {
            p.lines = [];
          }
          return p.lines.push(extra);
        });
      });
      parser.on('skip', function(test) {
        var base;
        if ((base = _.last(parserStack)).skips == null) {
          base.skips = [];
        }
        return _.last(parserStack).skips.push(test);
      });
      return parser.on('todo', function(test) {
        var base;
        if ((base = _.last(parserStack)).skips == null) {
          base.skips = [];
        }
        return _.last(parserStack).skips.push(test);
      });
    };
    attachListeners(rootParser);
    passthrough = new PassThroughStream();
    passthrough.pipe(rootParser);
    writeHeader();
    rl = readline.createInterface({
      input: read_stream
    });
    rl.on('line', function(line) {
      if (line.match(/^[\s\t\n\r]*$/)) {
        return;
      }
      return passthrough.write(line + '\n', 'utf8');
    });
    return rl.on('close', writeFooter);
  });
};

if (require.main === module) {
  convert(process.stdin, process.stdout).then(function() {
    return process.exit();
  });
} else {
  module.exports = convert;
}
